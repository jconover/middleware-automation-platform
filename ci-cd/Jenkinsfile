// =============================================================================
// Enterprise Middleware Platform - Jenkins Pipeline
// =============================================================================

pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: maven
    image: maven:3.9-eclipse-temurin-17
    command: [cat]
    tty: true
  - name: podman
    image: quay.io/podman/stable:latest
    command: [cat]
    tty: true
    securityContext:
      privileged: true
  - name: ansible
    image: cytopia/ansible:latest
    command: [cat]
    tty: true
'''
        }
    }

    environment {
        APP_NAME = 'middleware-platform'
        REGISTRY = 'registry.local'
        DEPLOY_START_TIME = ''

        // AWS ECS Configuration (prod-aws)
        AWS_REGION = 'us-east-1'
        ECR_REPO = ''  // Set dynamically based on AWS account
        ECS_CLUSTER = 'mw-prod-cluster'
        ECS_SERVICE = 'mw-prod-liberty'
    }

    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod-aws'], description: 'Target environment')
        choice(name: 'DEPLOY_TYPE', choices: ['full', 'application-only'], description: 'Deployment type')
        booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Dry run mode')
        string(name: 'LIBERTY_VERSION', defaultValue: '24.0.0.1', description: 'Liberty version')
    }

    stages {
        stage('Checkout') {
            steps {
                script { env.DEPLOY_START_TIME = new Date().format("yyyy-MM-dd HH:mm:ss") }
                checkout scm
                echo """
                ════════════════════════════════════════════════════════════
                Enterprise Middleware Platform - CI/CD Pipeline
                Environment: ${params.ENVIRONMENT}
                Started:     ${env.DEPLOY_START_TIME}
                ════════════════════════════════════════════════════════════
                """
            }
        }

        stage('Build Application') {
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('maven') {
                    dir('sample-app') {
                        sh 'mvn clean package -DskipTests -B'
                    }
                }
            }
            post {
                success { archiveArtifacts artifacts: 'sample-app/target/*.war', fingerprint: true }
            }
        }

        stage('Build Container') {
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('podman') {
                    dir('containers/liberty') {
                        sh '''
                            mkdir -p apps
                            cp ../../sample-app/target/*.war apps/ 2>/dev/null || true
                            podman build -t liberty-app:${BUILD_NUMBER} -f Containerfile .
                        '''
                    }
                }
            }
        }

        stage('Push to Local Registry') {
            when {
                allOf {
                    expression { params.DEPLOY_TYPE != 'infrastructure-only' }
                    expression { params.ENVIRONMENT != 'prod-aws' }
                }
            }
            steps {
                container('podman') {
                    sh '''
                        podman tag liberty-app:${BUILD_NUMBER} ${REGISTRY}/${APP_NAME}:${BUILD_NUMBER}
                        podman tag liberty-app:${BUILD_NUMBER} ${REGISTRY}/${APP_NAME}:latest
                        podman push ${REGISTRY}/${APP_NAME}:${BUILD_NUMBER}
                        podman push ${REGISTRY}/${APP_NAME}:latest
                    '''
                }
            }
        }

        stage('Push to ECR') {
            when {
                allOf {
                    expression { params.DEPLOY_TYPE != 'infrastructure-only' }
                    expression { params.ENVIRONMENT == 'prod-aws' }
                }
            }
            steps {
                container('podman') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-prod']]) {
                        sh '''#!/bin/bash
                            set -e

                            # Disable command tracing to prevent credential exposure
                            set +x

                            # Get AWS account ID and set ECR repository URL
                            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>/dev/null)
                            if [ -z "${AWS_ACCOUNT_ID}" ]; then
                                echo "ERROR: Failed to retrieve AWS account ID"
                                exit 1
                            fi
                            ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/mw-prod-liberty"

                            # Login to ECR (password is masked by redirecting to /dev/null on error)
                            echo "Authenticating with ECR..."
                            ECR_PASSWORD=$(aws ecr get-login-password --region ${AWS_REGION} 2>/dev/null)
                            if [ -z "${ECR_PASSWORD}" ]; then
                                echo "ERROR: Failed to retrieve ECR login password"
                                exit 1
                            fi
                            echo "${ECR_PASSWORD}" | podman login --username AWS --password-stdin \
                                "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" 2>&1 | \
                                grep -v -i "password" || true
                            unset ECR_PASSWORD

                            # Re-enable command tracing for non-sensitive operations
                            set -x

                            # Tag and push to ECR
                            podman tag liberty-app:${BUILD_NUMBER} ${ECR_REPO}:${BUILD_NUMBER}
                            podman tag liberty-app:${BUILD_NUMBER} ${ECR_REPO}:latest
                            podman push ${ECR_REPO}:${BUILD_NUMBER}
                            podman push ${ECR_REPO}:latest

                            echo "Successfully pushed image to ECR with tag: ${BUILD_NUMBER}"
                        '''
                    }
                }
            }
        }

        stage('Deploy with Ansible') {
            when { expression { params.ENVIRONMENT != 'prod-aws' } }
            steps {
                container('ansible') {
                    dir('automated/ansible') {
                        sh '''
                            ANSIBLE_ARGS="-i inventory/${ENVIRONMENT}.yml playbooks/site.yml"
                            ANSIBLE_ARGS="${ANSIBLE_ARGS} -e app_version=${BUILD_NUMBER}"
                            ANSIBLE_ARGS="${ANSIBLE_ARGS} -e liberty_version=${LIBERTY_VERSION}"

                            if [ "${DRY_RUN}" = "true" ]; then
                                ANSIBLE_ARGS="${ANSIBLE_ARGS} --check"
                            fi

                            ansible-playbook ${ANSIBLE_ARGS}
                        '''
                    }
                }
            }
        }

        stage('Deploy to ECS') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod-aws' }
                    expression { !params.DRY_RUN }
                }
            }
            steps {
                container('podman') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-prod']]) {
                        sh '''#!/bin/bash
                            set -e

                            # Disable command tracing to prevent credential exposure in AWS CLI output
                            set +x

                            echo "Deploying to ECS cluster: ${ECS_CLUSTER}, service: ${ECS_SERVICE}"

                            # Force new deployment with the latest image
                            # Redirect verbose output to prevent ARN/account exposure
                            aws ecs update-service \
                                --cluster ${ECS_CLUSTER} \
                                --service ${ECS_SERVICE} \
                                --force-new-deployment \
                                --region ${AWS_REGION} \
                                --output text \
                                --query 'service.serviceName' 2>/dev/null || {
                                    echo "ERROR: Failed to update ECS service"
                                    exit 1
                                }

                            echo "Waiting for ECS service to stabilize (this may take several minutes)..."
                            aws ecs wait services-stable \
                                --cluster ${ECS_CLUSTER} \
                                --services ${ECS_SERVICE} \
                                --region ${AWS_REGION} 2>/dev/null || {
                                    echo "ERROR: ECS service failed to stabilize"
                                    exit 1
                                }

                            echo "ECS deployment complete!"
                        '''
                    }
                }
            }
        }

        stage('Health Check') {
            when { expression { !params.DRY_RUN } }
            steps {
                script {
                    if (params.ENVIRONMENT == 'prod-aws') {
                        container('podman') {
                            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-prod']]) {
                                sh '''#!/bin/bash
                                    set -e

                                    # Disable command tracing to prevent infrastructure details exposure
                                    set +x

                                    echo "Checking ECS service health..."

                                    # Get ALB DNS name from AWS (suppress verbose output)
                                    ALB_DNS=$(aws elbv2 describe-load-balancers \
                                        --names mw-prod-alb \
                                        --query 'LoadBalancers[0].DNSName' \
                                        --output text \
                                        --region ${AWS_REGION} 2>/dev/null)

                                    if [ -z "${ALB_DNS}" ] || [ "${ALB_DNS}" = "None" ]; then
                                        echo "ERROR: Failed to retrieve ALB DNS name"
                                        exit 1
                                    fi

                                    # Health check with ECS routing header
                                    echo "Waiting for service to be ready..."
                                    sleep 30

                                    # Perform health check without exposing endpoint URL
                                    if curl -sf -H "X-Target: ecs" "http://${ALB_DNS}/health/ready" > /dev/null 2>&1; then
                                        echo "Health check passed!"
                                    else
                                        echo "ERROR: Health check failed"
                                        exit 1
                                    fi
                                '''
                            }
                        }
                    } else {
                        sh '''#!/bin/bash
                            set -e
                            echo "Waiting for service to be ready..."
                            sleep 30
                            if curl -sf "http://liberty.${ENVIRONMENT}.local/health/ready" > /dev/null 2>&1; then
                                echo "Health check passed!"
                            else
                                echo "ERROR: Health check failed"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                def endTime = new Date().format("yyyy-MM-dd HH:mm:ss")
                echo """
                ════════════════════════════════════════════════════════════
                DEPLOYMENT COMPLETE
                Status:    ${currentBuild.currentResult}
                Started:   ${env.DEPLOY_START_TIME}
                Completed: ${endTime}
                
                TIMING COMPARISON:
                Manual Deployment:    ~7 hours
                Automated Pipeline:   ~25 minutes
                ════════════════════════════════════════════════════════════
                """
            }
            cleanWs()
        }
    }
}
