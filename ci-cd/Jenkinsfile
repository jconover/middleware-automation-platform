// =============================================================================
// Enterprise Middleware Platform - Jenkins Pipeline
// =============================================================================

pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: maven
    image: maven:3.9-eclipse-temurin-17
    command: [cat]
    tty: true
  - name: podman
    image: quay.io/podman/stable:latest
    command: [cat]
    tty: true
    securityContext:
      runAsUser: 1000
      runAsGroup: 1000
    volumeMounts:
    - name: podman-storage
      mountPath: /home/podman/.local/share/containers
  - name: ansible
    image: cytopia/ansible:latest
    command: [cat]
    tty: true
  volumes:
  - name: podman-storage
    emptyDir: {}
'''
        }
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        APP_NAME = 'middleware-platform'
        REGISTRY = 'registry.local'
        DEPLOY_START_TIME = ''

        // AWS ECS Configuration - set dynamically in Checkout stage based on ENVIRONMENT
        AWS_REGION = 'us-east-1'
        ECR_REPO = ''  // Set dynamically based on AWS account
        ECS_CLUSTER = ''  // Set dynamically: mw-{env}-cluster
        ECS_SERVICE = ''  // Set dynamically: mw-{env}-liberty
        ALB_NAME = ''     // Set dynamically: mw-{env}-alb
        ECR_REPO_NAME = '' // Set dynamically: mw-{env}-liberty

        // Rollback tracking
        PREVIOUS_TASK_DEF_ARN = ''
        ECS_DEPLOYMENT_ATTEMPTED = 'false'

        // Versioning - populated in Checkout stage
        GIT_COMMIT_SHORT = ''
        VERSION = ''
        BUILD_TIMESTAMP = ''

        // Health check configuration
        HEALTH_CHECK_MAX_RETRIES = '30'
        HEALTH_CHECK_RETRY_DELAY = '10'
    }

    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod-aws'], description: 'Target environment')
        choice(name: 'DEPLOY_TYPE', choices: ['full', 'application-only'], description: 'Deployment type')
        booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Dry run mode')
        string(name: 'LIBERTY_VERSION', defaultValue: '24.0.0.1', description: 'Liberty version')
        string(name: 'AWS_CREDENTIALS_ID', defaultValue: 'aws-prod', description: 'Jenkins AWS credentials ID for AWS deployments')
    }

    stages {
        stage('Validate Parameters') {
            steps {
                script {
                    // Validate ENVIRONMENT parameter to prevent path traversal attacks
                    // Even though ENVIRONMENT is a choice parameter, validate as defense-in-depth
                    // since choice constraints can be bypassed via API calls or replay attacks
                    def allowedEnvironments = ['dev', 'staging', 'prod-aws']

                    if (!params.ENVIRONMENT) {
                        error("ENVIRONMENT parameter is required")
                    }

                    if (!allowedEnvironments.contains(params.ENVIRONMENT)) {
                        error("Invalid environment: '${params.ENVIRONMENT}'. Allowed values: ${allowedEnvironments.join(', ')}")
                    }

                    // Ensure no path traversal characters (defense-in-depth)
                    if (params.ENVIRONMENT.contains('/') || params.ENVIRONMENT.contains('\\') || params.ENVIRONMENT.contains('..')) {
                        error("ENVIRONMENT parameter contains invalid path characters: '${params.ENVIRONMENT}'")
                    }

                    // Validate LIBERTY_VERSION format (should be like '24.0.0.1')
                    if (params.LIBERTY_VERSION && !(params.LIBERTY_VERSION ==~ /^\d+\.\d+\.\d+\.\d+$/)) {
                        error("Invalid LIBERTY_VERSION format: '${params.LIBERTY_VERSION}'. Expected format: XX.X.X.X (e.g., 24.0.0.1)")
                    }

                    echo "Parameter validation passed: ENVIRONMENT=${params.ENVIRONMENT}, LIBERTY_VERSION=${params.LIBERTY_VERSION}"
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.DEPLOY_START_TIME = new Date().format("yyyy-MM-dd HH:mm:ss")
                    env.BUILD_TIMESTAMP = new Date().format("yyyyMMdd-HHmmss")
                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    env.VERSION = "${BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"

                    // Derive AWS resource names from environment parameter
                    // For prod-aws, extracts 'prod'; for others uses environment name directly
                    def envSuffix = params.ENVIRONMENT == 'prod-aws' ? 'prod' : params.ENVIRONMENT
                    def resourcePrefix = "mw-${envSuffix}"
                    env.ECS_CLUSTER = "${resourcePrefix}-cluster"
                    env.ECS_SERVICE = "${resourcePrefix}-liberty"
                    env.ALB_NAME = "${resourcePrefix}-alb"
                    env.ECR_REPO_NAME = "${resourcePrefix}-liberty"
                }
                echo """
                ════════════════════════════════════════════════════════════
                Enterprise Middleware Platform - CI/CD Pipeline
                Environment: ${params.ENVIRONMENT}
                Version:     ${env.VERSION}
                Commit:      ${env.GIT_COMMIT_SHORT}
                Started:     ${env.DEPLOY_START_TIME}
                ECS Cluster: ${env.ECS_CLUSTER}
                ECS Service: ${env.ECS_SERVICE}
                ════════════════════════════════════════════════════════════
                """
            }
        }

        stage('Build Application') {
            options {
                timeout(time: 15, unit: 'MINUTES')
            }
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('maven') {
                    dir('sample-app') {
                        sh 'mvn clean package -DskipTests -B'
                    }
                }
            }
            post {
                success { archiveArtifacts artifacts: 'sample-app/target/*.war', fingerprint: true }
            }
        }

        stage('Unit Tests') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('maven') {
                    dir('sample-app') {
                        sh 'mvn test -B'
                    }
                }
            }
            post {
                always {
                    junit testResults: 'sample-app/target/surefire-reports/*.xml', allowEmptyResults: true
                }
            }
        }

        stage('Code Quality') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('maven') {
                    dir('sample-app') {
                        sh 'mvn pmd:pmd checkstyle:checkstyle -B'
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'sample-app/target/site/*.xml', allowEmptyArchive: true
                    recordIssues(
                        tools: [
                            pmdParser(pattern: 'sample-app/target/pmd.xml'),
                            checkStyle(pattern: 'sample-app/target/checkstyle-result.xml')
                        ],
                        qualityGates: [[threshold: 50, type: 'TOTAL', unstable: true]]
                    )
                }
            }
        }

        stage('Build Container') {
            options {
                timeout(time: 20, unit: 'MINUTES')
            }
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('podman') {
                    dir('containers/liberty') {
                        sh '''
                            mkdir -p apps
                            cp ../../sample-app/target/*.war apps/ 2>/dev/null || true
                            podman build -t liberty-app:${VERSION} -f Containerfile .
                            echo "Built container image: liberty-app:${VERSION}"
                        '''
                    }
                }
            }
        }

        stage('Security Scan') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('podman') {
                    sh '''#!/bin/bash
                        set -e

                        # Trivy version and checksum configuration
                        # Update these values when upgrading Trivy
                        # Checksums available at: https://github.com/aquasecurity/trivy/releases
                        TRIVY_VERSION="0.48.3"
                        TRIVY_CHECKSUM="af0e3ac0c3f9ff5bd40a98063ea3e6bc0c7c99cd85ce22de3d38ed4dc8091e3d"

                        TRIVY_TARBALL="trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz"
                        TRIVY_URL="https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/${TRIVY_TARBALL}"
                        INSTALL_DIR="/usr/local/bin"
                        TEMP_DIR=$(mktemp -d)

                        # Cleanup function to remove temporary files
                        cleanup() {
                            rm -rf "${TEMP_DIR}"
                        }
                        trap cleanup EXIT

                        echo "Installing Trivy vulnerability scanner v${TRIVY_VERSION}..."
                        echo "Download URL: ${TRIVY_URL}"

                        # Download the release tarball
                        echo "Downloading Trivy tarball..."
                        if ! curl -fsSL -o "${TEMP_DIR}/${TRIVY_TARBALL}" "${TRIVY_URL}"; then
                            echo "ERROR: Failed to download Trivy from ${TRIVY_URL}"
                            exit 1
                        fi

                        # Verify SHA256 checksum
                        echo "Verifying SHA256 checksum..."
                        ACTUAL_CHECKSUM=$(sha256sum "${TEMP_DIR}/${TRIVY_TARBALL}" | awk '{print $1}')

                        if [ "${ACTUAL_CHECKSUM}" != "${TRIVY_CHECKSUM}" ]; then
                            echo "ERROR: Checksum verification failed!"
                            echo "  Expected: ${TRIVY_CHECKSUM}"
                            echo "  Actual:   ${ACTUAL_CHECKSUM}"
                            echo "This could indicate a corrupted download or supply chain attack."
                            exit 1
                        fi
                        echo "Checksum verified successfully"

                        # Extract and install
                        echo "Extracting Trivy..."
                        if ! tar -xzf "${TEMP_DIR}/${TRIVY_TARBALL}" -C "${TEMP_DIR}"; then
                            echo "ERROR: Failed to extract Trivy tarball"
                            exit 1
                        fi

                        if ! mv "${TEMP_DIR}/trivy" "${INSTALL_DIR}/trivy"; then
                            echo "ERROR: Failed to install Trivy to ${INSTALL_DIR}"
                            exit 1
                        fi

                        chmod +x "${INSTALL_DIR}/trivy"

                        # Verify installation
                        INSTALLED_VERSION=$(trivy --version 2>/dev/null | head -1 || echo "unknown")
                        echo "Trivy installed successfully: ${INSTALLED_VERSION}"
                        echo ""

                        echo "Scanning container image for vulnerabilities..."
                        echo "Image: liberty-app:${VERSION}"
                        echo ""

                        # Scan for HIGH and CRITICAL vulnerabilities
                        # Exit code 1 if CRITICAL vulnerabilities found
                        trivy image \
                            --severity HIGH,CRITICAL \
                            --exit-code 1 \
                            --no-progress \
                            --format table \
                            liberty-app:${VERSION}

                        echo ""
                        echo "Security scan completed successfully - no critical vulnerabilities found"
                    '''
                }
            }
            post {
                failure {
                    echo 'SECURITY SCAN FAILED: Critical vulnerabilities detected in container image'
                }
            }
        }

        stage('Push to Local Registry') {
            when {
                allOf {
                    expression { params.DEPLOY_TYPE != 'infrastructure-only' }
                    expression { params.ENVIRONMENT != 'prod-aws' }
                }
            }
            steps {
                container('podman') {
                    sh '''#!/bin/bash
                        set -e

                        # Tag with semantic version
                        podman tag liberty-app:${VERSION} ${REGISTRY}/${APP_NAME}:${VERSION}
                        podman push ${REGISTRY}/${APP_NAME}:${VERSION}
                        echo "Pushed ${REGISTRY}/${APP_NAME}:${VERSION}"

                        # Tag as 'latest' only on main branch
                        if [ "${GIT_BRANCH}" = "origin/main" ] || [ "${GIT_BRANCH}" = "main" ]; then
                            podman tag liberty-app:${VERSION} ${REGISTRY}/${APP_NAME}:latest
                            podman push ${REGISTRY}/${APP_NAME}:latest
                            echo "Pushed ${REGISTRY}/${APP_NAME}:latest"
                        fi
                    '''
                }
            }
        }

        stage('Push to ECR') {
            when {
                allOf {
                    expression { params.DEPLOY_TYPE != 'infrastructure-only' }
                    expression { params.ENVIRONMENT == 'prod-aws' }
                }
            }
            steps {
                container('podman') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: params.AWS_CREDENTIALS_ID]]) {
                        sh '''#!/bin/bash
                            set -e

                            # Disable command tracing to prevent credential exposure
                            set +x

                            # AWS CLI wrapper with retry logic and exponential backoff
                            # Handles transient failures, throttling, and provides meaningful error messages
                            aws_cli_with_retry() {
                                local max_attempts=5
                                local base_delay=2
                                local max_delay=60
                                local attempt=1
                                local exit_code=0
                                local output=""
                                local error_output=""

                                while [ $attempt -le $max_attempts ]; do
                                    # Capture both stdout and stderr
                                    error_output=$(mktemp)
                                    output=$(aws "$@" 2>"${error_output}") && exit_code=0 || exit_code=$?

                                    if [ $exit_code -eq 0 ]; then
                                        rm -f "${error_output}"
                                        echo "${output}"
                                        return 0
                                    fi

                                    # Read and analyze error message
                                    local error_msg=$(cat "${error_output}")
                                    rm -f "${error_output}"

                                    # Check for specific error types
                                    if echo "${error_msg}" | grep -qi "ExpiredToken\|ExpiredTokenException"; then
                                        echo "ERROR: AWS credentials have expired. Please refresh credentials and retry." >&2
                                        return 1
                                    fi

                                    if echo "${error_msg}" | grep -qi "InvalidClientTokenId\|UnrecognizedClientException"; then
                                        echo "ERROR: Invalid AWS credentials. Verify AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY." >&2
                                        return 1
                                    fi

                                    if echo "${error_msg}" | grep -qi "AccessDenied\|UnauthorizedAccess"; then
                                        echo "ERROR: Access denied. The IAM role/user lacks required permissions for: aws $*" >&2
                                        return 1
                                    fi

                                    # Retryable errors: throttling, service unavailable, connection issues
                                    if echo "${error_msg}" | grep -qi "Throttling\|ThrottlingException\|Rate exceeded\|RequestLimitExceeded"; then
                                        echo "  [RETRY] Request throttled, backing off... (attempt ${attempt}/${max_attempts})" >&2
                                    elif echo "${error_msg}" | grep -qi "ServiceUnavailable\|InternalError\|ServiceException"; then
                                        echo "  [RETRY] AWS service temporarily unavailable (attempt ${attempt}/${max_attempts})" >&2
                                    elif echo "${error_msg}" | grep -qi "Could not connect\|Connection refused\|Network"; then
                                        echo "  [RETRY] Network connectivity issue (attempt ${attempt}/${max_attempts})" >&2
                                    else
                                        # Unknown error - log and fail
                                        echo "ERROR: AWS CLI command failed: aws $*" >&2
                                        echo "       Exit code: ${exit_code}" >&2
                                        echo "       Error: ${error_msg}" >&2
                                        return $exit_code
                                    fi

                                    # Calculate delay with exponential backoff and jitter
                                    local delay=$((base_delay * (2 ** (attempt - 1))))
                                    [ $delay -gt $max_delay ] && delay=$max_delay
                                    # Add random jitter (0-25% of delay)
                                    local jitter=$((RANDOM % (delay / 4 + 1)))
                                    delay=$((delay + jitter))

                                    echo "  Waiting ${delay}s before retry..." >&2
                                    sleep $delay
                                    attempt=$((attempt + 1))
                                done

                                echo "ERROR: AWS CLI command failed after ${max_attempts} attempts: aws $*" >&2
                                return 1
                            }

                            # Get AWS account ID and set ECR repository URL
                            echo "Retrieving AWS account ID..."
                            AWS_ACCOUNT_ID=$(aws_cli_with_retry sts get-caller-identity --query Account --output text)
                            if [ -z "${AWS_ACCOUNT_ID}" ]; then
                                echo "ERROR: Failed to retrieve AWS account ID"
                                exit 1
                            fi
                            ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"

                            # Login to ECR (password is masked by redirecting to /dev/null on error)
                            echo "Authenticating with ECR..."
                            ECR_PASSWORD=$(aws_cli_with_retry ecr get-login-password --region ${AWS_REGION})
                            if [ -z "${ECR_PASSWORD}" ]; then
                                echo "ERROR: Failed to retrieve ECR login password"
                                exit 1
                            fi
                            echo "${ECR_PASSWORD}" | podman login --username AWS --password-stdin \
                                "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" 2>&1 | \
                                grep -v -i "password" || true
                            unset ECR_PASSWORD

                            # Re-enable command tracing for non-sensitive operations
                            set -x

                            # Tag and push to ECR with semantic version
                            podman tag liberty-app:${VERSION} ${ECR_REPO}:${VERSION}
                            podman push ${ECR_REPO}:${VERSION}
                            echo "Successfully pushed image to ECR with tag: ${VERSION}"

                            # Tag as 'latest' only on main branch
                            if [ "${GIT_BRANCH}" = "origin/main" ] || [ "${GIT_BRANCH}" = "main" ]; then
                                podman tag liberty-app:${VERSION} ${ECR_REPO}:latest
                                podman push ${ECR_REPO}:latest
                                echo "Also tagged and pushed as 'latest'"
                            fi
                        '''
                    }
                }
            }
        }

        stage('Deploy with Ansible') {
            when { expression { params.ENVIRONMENT != 'prod-aws' } }
            steps {
                script {
                    // Verify inventory file exists before attempting deployment
                    // This provides early failure with clear error message
                    def inventoryPath = "automated/ansible/inventory/${params.ENVIRONMENT}.yml"
                    if (!fileExists(inventoryPath)) {
                        error("Ansible inventory file not found: ${inventoryPath}")
                    }
                }
                container('ansible') {
                    dir('automated/ansible') {
                        sh '''
                            ANSIBLE_ARGS="-i inventory/${ENVIRONMENT}.yml playbooks/site.yml"
                            ANSIBLE_ARGS="${ANSIBLE_ARGS} -e app_version=${VERSION}"
                            ANSIBLE_ARGS="${ANSIBLE_ARGS} -e liberty_version=${LIBERTY_VERSION}"

                            if [ "${DRY_RUN}" = "true" ]; then
                                ANSIBLE_ARGS="${ANSIBLE_ARGS} --check"
                            fi

                            ansible-playbook ${ANSIBLE_ARGS}
                        '''
                    }
                }
            }
        }

        stage('Deploy to ECS') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod-aws' }
                    expression { !params.DRY_RUN }
                }
            }
            steps {
                container('podman') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: params.AWS_CREDENTIALS_ID]]) {
                        script {
                            // Capture the current task definition ARN before deploying for rollback
                            env.PREVIOUS_TASK_DEF_ARN = sh(
                                script: '''#!/bin/bash
                                    set +x

                                    # AWS CLI wrapper with retry logic for this script block
                                    aws_cli_with_retry() {
                                        local max_attempts=5
                                        local base_delay=2
                                        local max_delay=60
                                        local attempt=1
                                        local exit_code=0
                                        local output=""
                                        local error_output=""

                                        while [ $attempt -le $max_attempts ]; do
                                            error_output=$(mktemp)
                                            output=$(aws "$@" 2>"${error_output}") && exit_code=0 || exit_code=$?

                                            if [ $exit_code -eq 0 ]; then
                                                rm -f "${error_output}"
                                                echo "${output}"
                                                return 0
                                            fi

                                            local error_msg=$(cat "${error_output}")
                                            rm -f "${error_output}"

                                            # Non-retryable errors
                                            if echo "${error_msg}" | grep -qi "ExpiredToken\|InvalidClientTokenId\|AccessDenied"; then
                                                echo "ERROR: AWS authentication/authorization failed" >&2
                                                return 1
                                            fi

                                            # Retryable errors
                                            if echo "${error_msg}" | grep -qi "Throttling\|ServiceUnavailable\|InternalError\|Could not connect"; then
                                                local delay=$((base_delay * (2 ** (attempt - 1))))
                                                [ $delay -gt $max_delay ] && delay=$max_delay
                                                echo "  [RETRY] Transient error, waiting ${delay}s (attempt ${attempt}/${max_attempts})" >&2
                                                sleep $delay
                                                attempt=$((attempt + 1))
                                                continue
                                            fi

                                            echo "ERROR: AWS CLI failed: ${error_msg}" >&2
                                            return $exit_code
                                        done
                                        return 1
                                    }

                                    aws_cli_with_retry ecs describe-services \
                                        --cluster ${ECS_CLUSTER} \
                                        --services ${ECS_SERVICE} \
                                        --region ${AWS_REGION} \
                                        --query 'services[0].taskDefinition' \
                                        --output text
                                ''',
                                returnStdout: true
                            ).trim()

                            echo "Captured previous task definition for rollback: ${env.PREVIOUS_TASK_DEF_ARN}"
                            env.ECS_DEPLOYMENT_ATTEMPTED = 'true'
                        }

                        sh '''#!/bin/bash
                            set -e

                            # Disable command tracing to prevent credential exposure in AWS CLI output
                            set +x

                            # AWS CLI wrapper with retry logic and exponential backoff
                            aws_cli_with_retry() {
                                local max_attempts=5
                                local base_delay=2
                                local max_delay=60
                                local attempt=1
                                local exit_code=0
                                local output=""
                                local error_output=""

                                while [ $attempt -le $max_attempts ]; do
                                    error_output=$(mktemp)
                                    output=$(aws "$@" 2>"${error_output}") && exit_code=0 || exit_code=$?

                                    if [ $exit_code -eq 0 ]; then
                                        rm -f "${error_output}"
                                        echo "${output}"
                                        return 0
                                    fi

                                    local error_msg=$(cat "${error_output}")
                                    rm -f "${error_output}"

                                    # Non-retryable credential/permission errors
                                    if echo "${error_msg}" | grep -qi "ExpiredToken\|ExpiredTokenException"; then
                                        echo "ERROR: AWS credentials have expired. Please refresh credentials and retry." >&2
                                        return 1
                                    fi

                                    if echo "${error_msg}" | grep -qi "InvalidClientTokenId\|UnrecognizedClientException"; then
                                        echo "ERROR: Invalid AWS credentials." >&2
                                        return 1
                                    fi

                                    if echo "${error_msg}" | grep -qi "AccessDenied\|UnauthorizedAccess"; then
                                        echo "ERROR: Access denied for: aws $*" >&2
                                        return 1
                                    fi

                                    # Service not found - not retryable
                                    if echo "${error_msg}" | grep -qi "ServiceNotFound\|ServiceNotFoundException"; then
                                        echo "ERROR: ECS service not found: ${ECS_SERVICE}" >&2
                                        return 1
                                    fi

                                    # Cluster not found - not retryable
                                    if echo "${error_msg}" | grep -qi "ClusterNotFoundException"; then
                                        echo "ERROR: ECS cluster not found: ${ECS_CLUSTER}" >&2
                                        return 1
                                    fi

                                    # Retryable errors
                                    if echo "${error_msg}" | grep -qi "Throttling\|ThrottlingException\|Rate exceeded"; then
                                        echo "  [RETRY] Request throttled (attempt ${attempt}/${max_attempts})" >&2
                                    elif echo "${error_msg}" | grep -qi "ServiceUnavailable\|InternalError"; then
                                        echo "  [RETRY] AWS service temporarily unavailable (attempt ${attempt}/${max_attempts})" >&2
                                    elif echo "${error_msg}" | grep -qi "Could not connect\|Connection refused"; then
                                        echo "  [RETRY] Network issue (attempt ${attempt}/${max_attempts})" >&2
                                    else
                                        echo "ERROR: AWS CLI failed: aws $*" >&2
                                        echo "       Error: ${error_msg}" >&2
                                        return $exit_code
                                    fi

                                    local delay=$((base_delay * (2 ** (attempt - 1))))
                                    [ $delay -gt $max_delay ] && delay=$max_delay
                                    local jitter=$((RANDOM % (delay / 4 + 1)))
                                    delay=$((delay + jitter))

                                    echo "  Waiting ${delay}s before retry..." >&2
                                    sleep $delay
                                    attempt=$((attempt + 1))
                                done

                                echo "ERROR: AWS CLI command failed after ${max_attempts} attempts" >&2
                                return 1
                            }

                            echo "Deploying to ECS cluster: ${ECS_CLUSTER}, service: ${ECS_SERVICE}"

                            # Force new deployment with the latest image
                            if ! aws_cli_with_retry ecs update-service \
                                --cluster ${ECS_CLUSTER} \
                                --service ${ECS_SERVICE} \
                                --force-new-deployment \
                                --region ${AWS_REGION} \
                                --output text \
                                --query 'service.serviceName' > /dev/null; then
                                echo "ERROR: Failed to update ECS service"
                                exit 1
                            fi
                            echo "ECS service update initiated successfully"

                            echo "Waiting for ECS service to stabilize (this may take several minutes)..."
                            # Note: aws ecs wait has built-in retry, but we wrap for consistent error handling
                            if ! aws_cli_with_retry ecs wait services-stable \
                                --cluster ${ECS_CLUSTER} \
                                --services ${ECS_SERVICE} \
                                --region ${AWS_REGION}; then
                                echo "ERROR: ECS service failed to stabilize within timeout"
                                echo "       Check ECS console for deployment status and task health"
                                exit 1
                            fi

                            echo "ECS deployment complete!"
                        '''
                    }
                }
            }
            post {
                failure {
                    script {
                        if (env.PREVIOUS_TASK_DEF_ARN && env.PREVIOUS_TASK_DEF_ARN != 'None' && env.PREVIOUS_TASK_DEF_ARN != '') {
                            echo "ECS deployment failed. Initiating rollback to previous task definition..."
                            container('podman') {
                                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: params.AWS_CREDENTIALS_ID]]) {
                                    sh '''#!/bin/bash
                                        set +x

                                        # AWS CLI wrapper with retry for rollback operations
                                        aws_cli_with_retry() {
                                            local max_attempts=5
                                            local base_delay=2
                                            local max_delay=60
                                            local attempt=1
                                            local exit_code=0
                                            local output=""
                                            local error_output=""

                                            while [ $attempt -le $max_attempts ]; do
                                                error_output=$(mktemp)
                                                output=$(aws "$@" 2>"${error_output}") && exit_code=0 || exit_code=$?

                                                if [ $exit_code -eq 0 ]; then
                                                    rm -f "${error_output}"
                                                    echo "${output}"
                                                    return 0
                                                fi

                                                local error_msg=$(cat "${error_output}")
                                                rm -f "${error_output}"

                                                # Non-retryable errors
                                                if echo "${error_msg}" | grep -qi "ExpiredToken\|InvalidClientTokenId\|AccessDenied"; then
                                                    echo "ERROR: AWS authentication/authorization failed during rollback" >&2
                                                    echo "       Manual intervention required" >&2
                                                    return 1
                                                fi

                                                # Retryable errors - critical during rollback
                                                if echo "${error_msg}" | grep -qi "Throttling\|ServiceUnavailable\|InternalError\|Could not connect"; then
                                                    local delay=$((base_delay * (2 ** (attempt - 1))))
                                                    [ $delay -gt $max_delay ] && delay=$max_delay
                                                    echo "  [RETRY] Transient error during rollback, waiting ${delay}s (attempt ${attempt}/${max_attempts})" >&2
                                                    sleep $delay
                                                    attempt=$((attempt + 1))
                                                    continue
                                                fi

                                                echo "ERROR: Rollback AWS CLI failed: ${error_msg}" >&2
                                                return $exit_code
                                            done
                                            return 1
                                        }

                                        echo "Rolling back to task definition: ${PREVIOUS_TASK_DEF_ARN}"

                                        if ! aws_cli_with_retry ecs update-service \
                                            --cluster ${ECS_CLUSTER} \
                                            --service ${ECS_SERVICE} \
                                            --task-definition ${PREVIOUS_TASK_DEF_ARN} \
                                            --region ${AWS_REGION} \
                                            --output text \
                                            --query 'service.serviceName' > /dev/null; then
                                            echo "ERROR: Rollback failed - manual intervention required"
                                            echo "       Task definition to restore: ${PREVIOUS_TASK_DEF_ARN}"
                                            echo "       Command: aws ecs update-service --cluster ${ECS_CLUSTER} --service ${ECS_SERVICE} --task-definition ${PREVIOUS_TASK_DEF_ARN}"
                                            exit 1
                                        fi

                                        echo "Waiting for rollback to complete..."
                                        if ! aws_cli_with_retry ecs wait services-stable \
                                            --cluster ${ECS_CLUSTER} \
                                            --services ${ECS_SERVICE} \
                                            --region ${AWS_REGION}; then
                                            echo "WARNING: Rollback may not have completed successfully"
                                            echo "         Check ECS console: https://console.aws.amazon.com/ecs/home?region=${AWS_REGION}#/clusters/${ECS_CLUSTER}/services/${ECS_SERVICE}"
                                        else
                                            echo "Rollback completed successfully"
                                        fi
                                    '''
                                }
                            }
                        } else {
                            echo "No previous task definition available for rollback"
                        }
                    }
                }
            }
        }

        stage('Health Check') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            when { expression { !params.DRY_RUN } }
            steps {
                script {
                    if (params.ENVIRONMENT == 'prod-aws') {
                        container('podman') {
                            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: params.AWS_CREDENTIALS_ID]]) {
                                sh '''#!/bin/bash
                                    set -e

                                    # Disable command tracing to prevent infrastructure details exposure
                                    set +x

                                    # Validate endpoint path to prevent path traversal and injection attacks
                                    # Returns 0 if valid, 1 if invalid
                                    validate_endpoint_path() {
                                        local path="$1"

                                        # Path must start with /
                                        if [[ ! "${path}" =~ ^/ ]]; then
                                            echo "ERROR: Endpoint path must start with '/': ${path}"
                                            return 1
                                        fi

                                        # Block path traversal patterns
                                        if [[ "${path}" =~ \.\. ]]; then
                                            echo "ERROR: Endpoint path contains suspicious pattern '..': ${path}"
                                            return 1
                                        fi

                                        # Block double slashes (could be used for protocol injection)
                                        if [[ "${path}" =~ // ]]; then
                                            echo "ERROR: Endpoint path contains suspicious pattern '//': ${path}"
                                            return 1
                                        fi

                                        # Only allow alphanumeric characters, /, -, _
                                        if [[ ! "${path}" =~ ^[a-zA-Z0-9/_-]+$ ]]; then
                                            echo "ERROR: Endpoint path contains invalid characters: ${path}"
                                            echo "       Only alphanumeric, '/', '-', and '_' are allowed"
                                            return 1
                                        fi

                                        return 0
                                    }

                                    # Health check function with retry logic
                                    check_endpoint() {
                                        local endpoint="$1"
                                        local description="$2"
                                        local attempt=1

                                        # Validate endpoint path before making request
                                        if ! validate_endpoint_path "${endpoint}"; then
                                            echo "  [FAIL] ${description} - invalid endpoint path"
                                            return 1
                                        fi

                                        echo "Checking ${description}..."
                                        while [ $attempt -le ${HEALTH_CHECK_MAX_RETRIES} ]; do
                                            if curl -sf -H "X-Target: ecs" --connect-timeout 5 --max-time 10 \
                                                "http://${ALB_DNS}${endpoint}" > /dev/null 2>&1; then
                                                echo "  [PASS] ${description} (attempt ${attempt}/${HEALTH_CHECK_MAX_RETRIES})"
                                                return 0
                                            fi
                                            echo "  [RETRY] ${description} - attempt ${attempt}/${HEALTH_CHECK_MAX_RETRIES}, waiting ${HEALTH_CHECK_RETRY_DELAY}s..."
                                            sleep ${HEALTH_CHECK_RETRY_DELAY}
                                            attempt=$((attempt + 1))
                                        done
                                        echo "  [FAIL] ${description} - exhausted all ${HEALTH_CHECK_MAX_RETRIES} retries"
                                        return 1
                                    }

                                    # AWS CLI wrapper with retry logic for health check operations
                                    aws_cli_with_retry() {
                                        local max_attempts=5
                                        local base_delay=2
                                        local max_delay=60
                                        local attempt=1
                                        local exit_code=0
                                        local output=""
                                        local error_output=""

                                        while [ $attempt -le $max_attempts ]; do
                                            error_output=$(mktemp)
                                            output=$(aws "$@" 2>"${error_output}") && exit_code=0 || exit_code=$?

                                            if [ $exit_code -eq 0 ]; then
                                                rm -f "${error_output}"
                                                echo "${output}"
                                                return 0
                                            fi

                                            local error_msg=$(cat "${error_output}")
                                            rm -f "${error_output}"

                                            # Non-retryable errors
                                            if echo "${error_msg}" | grep -qi "ExpiredToken\|InvalidClientTokenId\|AccessDenied"; then
                                                echo "ERROR: AWS authentication/authorization failed" >&2
                                                return 1
                                            fi

                                            if echo "${error_msg}" | grep -qi "LoadBalancerNotFound"; then
                                                echo "ERROR: ALB not found: ${ALB_NAME}" >&2
                                                return 1
                                            fi

                                            # Retryable errors
                                            if echo "${error_msg}" | grep -qi "Throttling\|ServiceUnavailable\|InternalError\|Could not connect"; then
                                                local delay=$((base_delay * (2 ** (attempt - 1))))
                                                [ $delay -gt $max_delay ] && delay=$max_delay
                                                echo "  [RETRY] Transient error, waiting ${delay}s (attempt ${attempt}/${max_attempts})" >&2
                                                sleep $delay
                                                attempt=$((attempt + 1))
                                                continue
                                            fi

                                            echo "ERROR: AWS CLI failed: ${error_msg}" >&2
                                            return $exit_code
                                        done
                                        return 1
                                    }

                                    echo "================================================================"
                                    echo "ECS Health Check - Version: ${VERSION}"
                                    echo "Max retries: ${HEALTH_CHECK_MAX_RETRIES}, Delay: ${HEALTH_CHECK_RETRY_DELAY}s"
                                    echo "================================================================"

                                    # Wait for ECS service to stabilize
                                    echo "Waiting for ECS service to stabilize..."
                                    if ! aws_cli_with_retry ecs wait services-stable \
                                        --cluster ${ECS_CLUSTER} \
                                        --services ${ECS_SERVICE} \
                                        --region ${AWS_REGION}; then
                                        echo "WARNING: ECS wait timed out or failed, proceeding with health checks..."
                                    fi

                                    # Get ALB DNS name from AWS
                                    echo "Retrieving ALB DNS name..."
                                    ALB_DNS=$(aws_cli_with_retry elbv2 describe-load-balancers \
                                        --names ${ALB_NAME} \
                                        --query 'LoadBalancers[0].DNSName' \
                                        --output text \
                                        --region ${AWS_REGION})

                                    if [ -z "${ALB_DNS}" ] || [ "${ALB_DNS}" = "None" ]; then
                                        echo "ERROR: Failed to retrieve ALB DNS name"
                                        exit 1
                                    fi

                                    # Track overall health check status
                                    HEALTH_CHECK_FAILED=0

                                    # Check multiple endpoints
                                    echo ""
                                    echo "Validating application endpoints..."
                                    echo "----------------------------------------------------------------"

                                    # Primary health check - readiness probe
                                    if ! check_endpoint "/health/ready" "Readiness probe"; then
                                        HEALTH_CHECK_FAILED=1
                                    fi

                                    # Secondary health check - API info endpoint
                                    if ! check_endpoint "/api/info" "API info endpoint"; then
                                        HEALTH_CHECK_FAILED=1
                                    fi

                                    # Tertiary health check - metrics endpoint
                                    if ! check_endpoint "/metrics" "Metrics endpoint"; then
                                        echo "  [WARN] Metrics endpoint not responding (non-critical)"
                                    fi

                                    echo "----------------------------------------------------------------"

                                    if [ $HEALTH_CHECK_FAILED -eq 1 ]; then
                                        echo "ERROR: One or more critical health checks failed"
                                        exit 1
                                    fi

                                    echo ""
                                    echo "All critical health checks passed!"
                                '''
                            }
                        }
                    } else {
                        sh '''#!/bin/bash
                            set -e

                            # Validate endpoint path to prevent path traversal and injection attacks
                            # Returns 0 if valid, 1 if invalid
                            validate_endpoint_path() {
                                local path="$1"

                                # Path must start with /
                                if [[ ! "${path}" =~ ^/ ]]; then
                                    echo "ERROR: Endpoint path must start with '/': ${path}"
                                    return 1
                                fi

                                # Block path traversal patterns
                                if [[ "${path}" =~ \.\. ]]; then
                                    echo "ERROR: Endpoint path contains suspicious pattern '..': ${path}"
                                    return 1
                                fi

                                # Block double slashes (could be used for protocol injection)
                                if [[ "${path}" =~ // ]]; then
                                    echo "ERROR: Endpoint path contains suspicious pattern '//': ${path}"
                                    return 1
                                fi

                                # Only allow alphanumeric characters, /, -, _
                                if [[ ! "${path}" =~ ^[a-zA-Z0-9/_-]+$ ]]; then
                                    echo "ERROR: Endpoint path contains invalid characters: ${path}"
                                    echo "       Only alphanumeric, '/', '-', and '_' are allowed"
                                    return 1
                                fi

                                return 0
                            }

                            # Health check function with retry logic
                            check_endpoint() {
                                local base_url="$1"
                                local endpoint="$2"
                                local description="$3"
                                local attempt=1

                                # Validate endpoint path before making request
                                if ! validate_endpoint_path "${endpoint}"; then
                                    echo "  [FAIL] ${description} - invalid endpoint path"
                                    return 1
                                fi

                                echo "Checking ${description}..."
                                while [ $attempt -le ${HEALTH_CHECK_MAX_RETRIES} ]; do
                                    if curl -sf --connect-timeout 5 --max-time 10 \
                                        "${base_url}${endpoint}" > /dev/null 2>&1; then
                                        echo "  [PASS] ${description} (attempt ${attempt}/${HEALTH_CHECK_MAX_RETRIES})"
                                        return 0
                                    fi
                                    echo "  [RETRY] ${description} - attempt ${attempt}/${HEALTH_CHECK_MAX_RETRIES}, waiting ${HEALTH_CHECK_RETRY_DELAY}s..."
                                    sleep ${HEALTH_CHECK_RETRY_DELAY}
                                    attempt=$((attempt + 1))
                                done
                                echo "  [FAIL] ${description} - exhausted all ${HEALTH_CHECK_MAX_RETRIES} retries"
                                return 1
                            }

                            BASE_URL="http://liberty.${ENVIRONMENT}.local"

                            echo "================================================================"
                            echo "Health Check - Version: ${VERSION}"
                            echo "Target: ${BASE_URL}"
                            echo "Max retries: ${HEALTH_CHECK_MAX_RETRIES}, Delay: ${HEALTH_CHECK_RETRY_DELAY}s"
                            echo "================================================================"

                            # Track overall health check status
                            HEALTH_CHECK_FAILED=0

                            echo ""
                            echo "Validating application endpoints..."
                            echo "----------------------------------------------------------------"

                            # Primary health check - readiness probe
                            if ! check_endpoint "${BASE_URL}" "/health/ready" "Readiness probe"; then
                                HEALTH_CHECK_FAILED=1
                            fi

                            # Secondary health check - API info endpoint
                            if ! check_endpoint "${BASE_URL}" "/api/info" "API info endpoint"; then
                                HEALTH_CHECK_FAILED=1
                            fi

                            # Tertiary health check - metrics endpoint
                            if ! check_endpoint "${BASE_URL}" "/metrics" "Metrics endpoint"; then
                                echo "  [WARN] Metrics endpoint not responding (non-critical)"
                            fi

                            echo "----------------------------------------------------------------"

                            if [ $HEALTH_CHECK_FAILED -eq 1 ]; then
                                echo "ERROR: One or more critical health checks failed"
                                exit 1
                            fi

                            echo ""
                            echo "All critical health checks passed!"
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                def endTime = new Date().format("yyyy-MM-dd HH:mm:ss")
                echo """
                ════════════════════════════════════════════════════════════
                DEPLOYMENT COMPLETE
                Status:    ${currentBuild.currentResult}
                Version:   ${env.VERSION ?: 'N/A'}
                Commit:    ${env.GIT_COMMIT_SHORT ?: 'N/A'}
                Started:   ${env.DEPLOY_START_TIME}
                Completed: ${endTime}

                TIMING COMPARISON:
                Manual Deployment:    ~7 hours
                Automated Pipeline:   ~25 minutes
                ════════════════════════════════════════════════════════════
                """
            }
            cleanWs()
        }

        success {
            script {
                def duration = currentBuild.durationString.replace(' and counting', '')
                def successMessage = """
                    *Deployment Successful*
                    Job: ${env.JOB_NAME}
                    Build: #${env.BUILD_NUMBER}
                    Environment: ${params.ENVIRONMENT}
                    Version: ${env.VERSION}
                    Duration: ${duration}
                    Build URL: ${env.BUILD_URL}
                """.stripIndent()

                echo successMessage

                // Send Slack notification if plugin is available
                try {
                    slackSend(
                        color: 'good',
                        channel: '#deployments',
                        message: successMessage
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped: ${e.message}"
                }
            }
        }

        failure {
            script {
                def duration = currentBuild.durationString.replace(' and counting', '')
                def failedStage = env.STAGE_NAME ?: 'Unknown'
                def rollbackStatus = (env.ECS_DEPLOYMENT_ATTEMPTED == 'true' && env.PREVIOUS_TASK_DEF_ARN) ?
                    'Rollback attempted' : 'No rollback performed'

                def failureMessage = """
                    *Deployment Failed*
                    Job: ${env.JOB_NAME}
                    Build: #${env.BUILD_NUMBER}
                    Environment: ${params.ENVIRONMENT}
                    Failed Stage: ${failedStage}
                    Duration: ${duration}
                    Rollback: ${rollbackStatus}
                    Build URL: ${env.BUILD_URL}
                """.stripIndent()

                echo failureMessage

                // Send Slack notification if plugin is available
                try {
                    slackSend(
                        color: 'danger',
                        channel: '#deployments',
                        message: failureMessage
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped: ${e.message}"
                }
            }
        }
    }
}
