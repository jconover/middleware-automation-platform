// =============================================================================
// Enterprise Middleware Platform - Jenkins Pipeline
// =============================================================================

pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: maven
    image: maven:3.9-eclipse-temurin-17
    command: [cat]
    tty: true
  - name: podman
    image: quay.io/podman/stable:latest
    command: [cat]
    tty: true
    securityContext:
      privileged: true
  - name: ansible
    image: cytopia/ansible:latest
    command: [cat]
    tty: true
'''
        }
    }

    environment {
        APP_NAME = 'middleware-platform'
        REGISTRY = 'registry.local'
        DEPLOY_START_TIME = ''

        // AWS ECS Configuration (prod-aws)
        AWS_REGION = 'us-east-1'
        ECR_REPO = ''  // Set dynamically based on AWS account
        ECS_CLUSTER = 'mw-prod-cluster'
        ECS_SERVICE = 'mw-prod-liberty'
    }

    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod-aws'], description: 'Target environment')
        choice(name: 'DEPLOY_TYPE', choices: ['full', 'application-only'], description: 'Deployment type')
        booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Dry run mode')
        string(name: 'LIBERTY_VERSION', defaultValue: '24.0.0.1', description: 'Liberty version')
    }

    stages {
        stage('Checkout') {
            steps {
                script { env.DEPLOY_START_TIME = new Date().format("yyyy-MM-dd HH:mm:ss") }
                checkout scm
                echo """
                ════════════════════════════════════════════════════════════
                Enterprise Middleware Platform - CI/CD Pipeline
                Environment: ${params.ENVIRONMENT}
                Started:     ${env.DEPLOY_START_TIME}
                ════════════════════════════════════════════════════════════
                """
            }
        }

        stage('Build Application') {
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('maven') {
                    dir('sample-app') {
                        sh 'mvn clean package -DskipTests -B'
                    }
                }
            }
            post {
                success { archiveArtifacts artifacts: 'sample-app/target/*.war', fingerprint: true }
            }
        }

        stage('Build Container') {
            when { expression { params.DEPLOY_TYPE != 'infrastructure-only' } }
            steps {
                container('podman') {
                    dir('containers/liberty') {
                        sh '''
                            mkdir -p apps
                            cp ../../sample-app/target/*.war apps/ 2>/dev/null || true
                            podman build -t liberty-app:${BUILD_NUMBER} -f Containerfile .
                        '''
                    }
                }
            }
        }

        stage('Push to Local Registry') {
            when {
                allOf {
                    expression { params.DEPLOY_TYPE != 'infrastructure-only' }
                    expression { params.ENVIRONMENT != 'prod-aws' }
                }
            }
            steps {
                container('podman') {
                    sh '''
                        podman tag liberty-app:${BUILD_NUMBER} ${REGISTRY}/${APP_NAME}:${BUILD_NUMBER}
                        podman tag liberty-app:${BUILD_NUMBER} ${REGISTRY}/${APP_NAME}:latest
                        podman push ${REGISTRY}/${APP_NAME}:${BUILD_NUMBER}
                        podman push ${REGISTRY}/${APP_NAME}:latest
                    '''
                }
            }
        }

        stage('Push to ECR') {
            when {
                allOf {
                    expression { params.DEPLOY_TYPE != 'infrastructure-only' }
                    expression { params.ENVIRONMENT == 'prod-aws' }
                }
            }
            steps {
                container('podman') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-prod']]) {
                        sh '''
                            # Get AWS account ID and set ECR repository URL
                            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
                            ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/mw-prod-liberty"

                            # Login to ECR
                            aws ecr get-login-password --region ${AWS_REGION} | \
                                podman login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

                            # Tag and push to ECR
                            podman tag liberty-app:${BUILD_NUMBER} ${ECR_REPO}:${BUILD_NUMBER}
                            podman tag liberty-app:${BUILD_NUMBER} ${ECR_REPO}:latest
                            podman push ${ECR_REPO}:${BUILD_NUMBER}
                            podman push ${ECR_REPO}:latest

                            echo "Pushed image to ECR: ${ECR_REPO}:${BUILD_NUMBER}"
                        '''
                    }
                }
            }
        }

        stage('Deploy with Ansible') {
            when { expression { params.ENVIRONMENT != 'prod-aws' } }
            steps {
                container('ansible') {
                    dir('automated/ansible') {
                        sh '''
                            ANSIBLE_ARGS="-i inventory/${ENVIRONMENT}.yml playbooks/site.yml"
                            ANSIBLE_ARGS="${ANSIBLE_ARGS} -e app_version=${BUILD_NUMBER}"
                            ANSIBLE_ARGS="${ANSIBLE_ARGS} -e liberty_version=${LIBERTY_VERSION}"

                            if [ "${DRY_RUN}" = "true" ]; then
                                ANSIBLE_ARGS="${ANSIBLE_ARGS} --check"
                            fi

                            ansible-playbook ${ANSIBLE_ARGS}
                        '''
                    }
                }
            }
        }

        stage('Deploy to ECS') {
            when {
                allOf {
                    expression { params.ENVIRONMENT == 'prod-aws' }
                    expression { !params.DRY_RUN }
                }
            }
            steps {
                container('podman') {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-prod']]) {
                        sh '''
                            echo "Deploying to ECS..."

                            # Force new deployment with the latest image
                            aws ecs update-service \
                                --cluster ${ECS_CLUSTER} \
                                --service ${ECS_SERVICE} \
                                --force-new-deployment \
                                --region ${AWS_REGION}

                            echo "Waiting for ECS service to stabilize..."
                            aws ecs wait services-stable \
                                --cluster ${ECS_CLUSTER} \
                                --services ${ECS_SERVICE} \
                                --region ${AWS_REGION}

                            echo "ECS deployment complete!"
                        '''
                    }
                }
            }
        }

        stage('Health Check') {
            when { expression { !params.DRY_RUN } }
            steps {
                script {
                    if (params.ENVIRONMENT == 'prod-aws') {
                        container('podman') {
                            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-prod']]) {
                                sh '''
                                    echo "Checking ECS service health..."

                                    # Get ALB DNS name from Terraform outputs or AWS
                                    ALB_DNS=$(aws elbv2 describe-load-balancers \
                                        --names mw-prod-alb \
                                        --query 'LoadBalancers[0].DNSName' \
                                        --output text \
                                        --region ${AWS_REGION})

                                    # Health check with ECS routing header
                                    sleep 30
                                    curl -sf -H "X-Target: ecs" "http://${ALB_DNS}/health/ready" || exit 1

                                    echo "Health check passed!"
                                '''
                            }
                        }
                    } else {
                        sh '''
                            sleep 30
                            curl -sf http://liberty.${ENVIRONMENT}.local/health/ready || exit 1
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                def endTime = new Date().format("yyyy-MM-dd HH:mm:ss")
                echo """
                ════════════════════════════════════════════════════════════
                DEPLOYMENT COMPLETE
                Status:    ${currentBuild.currentResult}
                Started:   ${env.DEPLOY_START_TIME}
                Completed: ${endTime}
                
                TIMING COMPARISON:
                Manual Deployment:    ~7 hours
                Automated Pipeline:   ~25 minutes
                ════════════════════════════════════════════════════════════
                """
            }
            cleanWs()
        }
    }
}
